(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{322:function(e,t,a){"use strict";a.r(t);var r=a(0),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流"}},[e._v("#")]),e._v(" 流")]),e._v(" "),a("p",[e._v("流（stream）是 Node.js 中处理流式数据的抽象接口。流也是一种数据传输手段，是有顺序的，有起点和终点的，比如你要把数据从一个地方传到另一个地方。")]),e._v(" "),a("p",[e._v("为什么流那么好用还那么重要呢？")]),e._v(" "),a("ul",[a("li",[e._v("因为有时候我们并不需要关心文件的主体内容，只需关心能不能取到数据，取到数据之后怎么进行处理")]),e._v(" "),a("li",[e._v("对于小型的文本文件，我们可以把文件内容全部读入内存，然后再写入文件")]),e._v(" "),a("li",[e._v("对于体积较大的二进制文件，比如音频、视频等多媒体文件，动辄几个 GB 大小，如果使用常规方法读取，很容易使内存溢出")]),e._v(" "),a("li",[e._v("理想的方法应该是读一部分，写一部分，不管文件有多大，只要时间允许，总会处理完成，这里就需要用到流的概念")])]),e._v(" "),a("p",[a("code",[e._v("stream")]),e._v(" 模块是 Node.js 中用于构建实现了流接口的对象。")]),e._v(" "),a("p",[e._v("🌰 "),a("strong",[e._v("示例")]),e._v("：访问 "),a("code",[e._v("stream")]),e._v(" 模块")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" stream "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'stream'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("尽管理解流的工作方式很重要，但是 "),a("code",[e._v("stream")]),e._v(" 模块主要用于开发者创建新类型的流实例。 对于以消费流对象为主的开发者，极少需要直接使用 "),a("code",[e._v("stream")]),e._v(" 模块。")]),e._v(" "),a("h2",{attrs:{id:"流的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流的类型"}},[e._v("#")]),e._v(" 流的类型")]),e._v(" "),a("p",[e._v("在 Node.js 中对文件的处理多数使用流来完成：")]),e._v(" "),a("ul",[a("li",[e._v("普通文件")]),e._v(" "),a("li",[e._v("设备文件（stdin、stdout）")]),e._v(" "),a("li",[e._v("网络文件（http、net）")])]),e._v(" "),a("p",[e._v("在 Node.js 中有四种基本的流类型：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Writable")]),e._v("（可写流）：可写流是数据可以被写入目标的抽象（例如 "),a("code",[e._v("fs.createWriteStream()")]),e._v("）")]),e._v(" "),a("li",[a("code",[e._v("Readable")]),e._v("（可读流）：可读流是数据可以被消费的抽象（例如 "),a("code",[e._v("fs.createReadStream()")]),e._v("）")]),e._v(" "),a("li",[a("code",[e._v("Duplex")]),e._v("（双向流）：双向流既是可写的也是可读的（例如 "),a("code",[e._v("net.Socket")]),e._v("）")]),e._v(" "),a("li",[a("code",[e._v("Transform")]),e._v("（转换流）：转向流基于双向流，可以在读或写的时候被用来更改或者转换数据（例如 "),a("code",[e._v("zlib.createDeflate()")]),e._v(" 使用 gzip 算法压缩数据）。可以将转换流想象成一个函数，它的输入是可写流，输出是可读流。某些地方也将转换流称为通过流（through streams）。")])]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" Stream "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'stream'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" Readable "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Stream"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("Readable"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" Writable "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Stream"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("Writable"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" Duplex "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Stream"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("Duplex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" Transform "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Stream"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("Transform"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("所有流都是 "),a("strong",[e._v("EventEmitter")]),e._v(" 的实例。触发它们的事件可以读或者写入数据，然而，我们可以使用 "),a("code",[e._v("pipe")]),e._v(" 方法消费流的数据。")]),e._v(" "),a("p",[e._v("此外，该模块还包括实用函数 "),a("code",[e._v("stream.pipeline()")]),e._v("、"),a("code",[e._v("stream.finished()")]),e._v(" 和 "),a("code",[e._v("stream.Readable.from()")]),e._v(" 方法。")]),e._v(" "),a("h3",{attrs:{id:"对象模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象模式"}},[e._v("#")]),e._v(" 对象模式")]),e._v(" "),a("p",[e._v("Node.js 创建的流都是运作在字符串和 Buffer（或 Uint8Array）上。 当然，流的实现也可以使用其它类型的 JavaScript 值（除了 null）。 这些流会以 "),a("code",[e._v("对象模式")]),e._v(" 进行操作。")]),e._v(" "),a("p",[e._v("当创建流时，可以使用 "),a("code",[e._v("objectMode")]),e._v(" 选项把流实例切换到"),a("strong",[e._v("对象模式")]),e._v("。 将已存在的流切换到对象模式是不安全的。")]),e._v(" "),a("h3",{attrs:{id:"缓冲"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓冲"}},[e._v("#")]),e._v(" 缓冲")]),e._v(" "),a("p",[a("code",[e._v("可写流")]),e._v(" 和 "),a("code",[e._v("可读流")]),e._v(" 都会在内部的"),a("strong",[e._v("缓冲器")]),e._v("中存储数据，可以分别使用的 "),a("code",[e._v("writable.writableBuffer")]),e._v(" 或 "),a("code",[e._v("readable.readableBuffer")]),e._v(" 来获取。")]),e._v(" "),a("p",[e._v("可缓冲的数据大小取决于传入流构造函数的 "),a("code",[e._v("highWaterMark")]),e._v(" 选项。")]),e._v(" "),a("ul",[a("li",[e._v("对于普通的流， "),a("code",[e._v("highWaterMark")]),e._v(" 指定了字节的总数")]),e._v(" "),a("li",[e._v("对于对象模式的流， "),a("code",[e._v("highWaterMark")]),e._v(" 指定了对象的总数")])]),e._v(" "),a("p",[e._v("当调用 "),a("code",[e._v("stream.push(chunk)")]),e._v(" 时，数据会被缓冲在可读流中。 如果流的消费者没有调用 "),a("code",[e._v("stream.read()")]),e._v("，则数据会保留在内部队列中直到被消费。")]),e._v(" "),a("p",[e._v("一旦内部的可读缓冲的总大小达到 "),a("code",[e._v("highWaterMark")]),e._v(" 指定的阈值时，流会暂时停止从底层资源读取数据，直到当前缓冲的数据被消费 （也就是说，流会停止调用内部的用于填充可读缓冲的 "),a("code",[e._v("readable._read()")]),e._v("）。")]),e._v(" "),a("p",[e._v("当调用 "),a("code",[e._v("writable.write(chunk)")]),e._v(" 时，数据会被缓冲在可写流中。 当内部的可写缓冲的总大小小于 "),a("code",[e._v("highWaterMark")]),e._v(" 设置的阈值时，调用 "),a("code",[e._v("writable.write()")]),e._v(" 会返回 "),a("code",[e._v("true")]),e._v("。 一旦内部缓冲的大小达到或超过 "),a("code",[e._v("highWaterMark")]),e._v(" 时，则会返回 "),a("code",[e._v("false")]),e._v("。")]),e._v(" "),a("p",[e._v("stream API 的主要目标，特别是 "),a("code",[e._v("stream.pipe()")]),e._v("，是为了限制数据的缓冲到可接受的程度，也就是读写速度不一致的源头与目的地不会压垮内存。")]),e._v(" "),a("p",[e._v("因为 Duplex 和 Transform 都是可读又可写的，所以它们各自维护着两个相互独立的内部缓冲器用于读取和写入， 这使得它们在维护数据流时，读取和写入两边可以各自独立地运作。 例如，net.Socket 实例是 Duplex 流，它的可读端可以消费从 socket 接收的数据，而可写端则可以将数据写入到 socket。 因为数据写入到 socket 的速度可能比接收数据的速度快或者慢，所以读写两端应该独立地进行操作（或缓冲）。")]),e._v(" "),a("hr"),e._v(" "),a("p",[a("strong",[e._v("参考资料：")])]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://tech.meituan.com/2016/07/08/stream-basics.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("美团 Node.js Stream - 基础篇"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://tech.meituan.com/2016/07/15/stream-internals.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("美团 Node.js Stream - 进阶篇"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://tech.meituan.com/2016/07/22/stream-in-action.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("美团 Node.js Stream - 实战篇"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/36728655",target:"_blank",rel:"noopener noreferrer"}},[e._v("📝 Node.js 流（stream）：你需要知道的一切"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://cnodejs.org/topic/56ba030271204e03637a3870",target:"_blank",rel:"noopener noreferrer"}},[e._v("通过源码解析 Node.js 中导流（pipe）的实现"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5d25ce36f265da1ba84ab97a",target:"_blank",rel:"noopener noreferrer"}},[e._v("想学Node.js，stream先有必要搞清楚"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/zoubin/streamify-your-node-program",target:"_blank",rel:"noopener noreferrer"}},[e._v("zoubin/streamify-your-node-program：对 Node.js 中 stream 模块的学习积累和理解"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=s.exports}}]);