(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{308:function(t,s,a){"use strict";a.r(s);var e=a(0),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"dgram"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dgram"}},[t._v("#")]),t._v(" Dgram")]),t._v(" "),a("p",[t._v("dgram 模块提供了 UDP 数据包 socket 的实现。")]),t._v(" "),a("h2",{attrs:{id:"dgram-socket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dgram-socket"}},[t._v("#")]),t._v(" dgram.Socket")]),t._v(" "),a("p",[t._v("dgram.Socket 对象是一个封装了数据包函数功能的 EventEmitter。")]),t._v(" "),a("p",[t._v("dgram.Socket 实例是由 "),a("code",[t._v("dgram.createSocket()")]),t._v(" 创建的。创建 dgram.Socket 实例不需要使用 "),a("code",[t._v("new")]),t._v(" 关键字。")]),t._v(" "),a("h3",{attrs:{id:"相关事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关事件"}},[t._v("#")]),t._v(" 相关事件")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("connect")]),t._v("：因 "),a("code",[t._v("connect()")]),t._v(" 调用成功而使 socket 与远程地址关联之后触发")]),t._v(" "),a("li",[a("strong",[t._v("message")]),t._v("：当有新的数据包被 socket 接收时触发。"),a("code",[t._v("msg")]),t._v(" 和 "),a("code",[t._v("rinfo")]),t._v(" 会作为参数传递到该事件的处理函数中")]),t._v(" "),a("li",[a("strong",[t._v("listening")]),t._v("：当 socket 开始监听数据包信息时触发该事件处理函数")]),t._v(" "),a("li",[a("strong",[t._v("close")]),t._v("：在调用 "),a("code",[t._v("close()")]),t._v(" 关闭 socket 时触发。该事件一旦触发，则该 socket 不会触发新的 "),a("code",[t._v("message")]),t._v(" 事件")]),t._v(" "),a("li",[a("strong",[t._v("error")]),t._v("：当有任何异常出现时触发该事件处理函数")])]),t._v(" "),a("h3",{attrs:{id:"socket-bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socket-bind"}},[t._v("#")]),t._v(" socket.bind")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("socket")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("port"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" address"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("socket")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("options"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("对于 UDP socket，该方法会令 "),a("code",[t._v("dgram.Socket")]),t._v(" 在指定的 port 和可选的 address 上监听数据包信息。若 "),a("code",[t._v("port")]),t._v(" 未指定或为 0,操作系统会尝试绑定一个随机的端口。若 "),a("code",[t._v("address")]),t._v(" 未指定，操作系统会尝试在所有地址上监听。绑定完成式会触发 "),a("code",[t._v("listening")]),t._v(" 事件，并会调用 "),a("code",[t._v("callback")]),t._v(" 方法。")]),t._v(" "),a("p",[t._v("一个被绑定的数据包 socket 会令 Node.js 进程保持运行以接收数据包信息。")]),t._v(" "),a("h3",{attrs:{id:"socket-send"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socket-send"}},[t._v("#")]),t._v(" socket.send")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("socket"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("send")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("msg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" offset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" port"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" address"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("在 socket 上广播一个数据包。对于无连接的 socket，必须指定目标的 port 和 address。对于连接的 socket，则将会使用其关联的远程端点，因此不能设置 port 和 address 参数。")]),t._v(" "),a("p",[a("strong",[t._v("msg 参数")])]),t._v(" "),a("p",[a("code",[t._v("msg")]),t._v(" 参数包含了要发送的消息。根据消息的类型可以有不同的做法。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("参数类型")]),t._v(" "),a("th",[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Buffer 或 Uint8Array")]),t._v(" "),a("td",[a("code",[t._v("offset")]),t._v(" 和 "),a("code",[t._v("length")]),t._v(" 指定了消息在 Buffer 中对应的偏移量和字节数")])]),t._v(" "),a("tr",[a("td",[t._v("String")]),t._v(" "),a("td",[t._v("自动按照 utf8 编码转换为 Buffer。对于包含了多字节字符的消息，"),a("code",[t._v("offset")]),t._v(" 和 "),a("code",[t._v("length")]),t._v(" 会根据对应的字节长度进行计算，而不是根据字符的位置")])]),t._v(" "),a("tr",[a("td",[t._v("Array")]),t._v(" "),a("td",[a("code",[t._v("offset")]),t._v(" 和 "),a("code",[t._v("length")]),t._v(" 必须都不能被指定")])])])]),t._v(" "),a("p",[a("strong",[t._v("address 参数")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("参数类型")]),t._v(" "),a("th",[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("String")]),t._v(" "),a("td",[t._v("值为主机名，则 DNS 会被用来解析主机的地址")])]),t._v(" "),a("tr",[a("td",[t._v("未提供或非真值")]),t._v(" "),a("td",[t._v("则 "),a("code",[t._v("127.0.0.1")]),t._v("（用于 udp4 socket）或 "),a("code",[t._v("::1")]),t._v("（用于 udp6 socket）会被使用")])])])]),t._v(" "),a("p",[t._v("可以指定一个可选的 "),a("code",[t._v("callback")]),t._v(" 方法来汇报 DNS 错误或判断可以安全地重用 "),a("code",[t._v("buf")]),t._v(" 对象的时机。在 Node.js 事件循环中，DNS 查询会对发送造成至少一个时间点的延迟。")]),t._v(" "),a("p",[t._v("确定数据包被发送的唯一方式就是指定 "),a("code",[t._v("callback")]),t._v("。若 "),a("code",[t._v("callback")]),t._v(" 被指定的情况下有错误发生，该错误会作为 "),a("code",[t._v("callback")]),t._v(" 的第一个参数。若 "),a("code",[t._v("callback")]),t._v(" 未被指定，该错误会以 "),a("code",[t._v("error")]),t._v(" 事件的形式投射到 socket 对象上。")]),t._v(" "),a("p",[t._v("偏移量和长度是可选的，但如果其中一个被指定则另一个也必须被指定。另外，它们只在第一个参数是 Buffer 或 Uint8Array 的情况下才能被使用。")]),t._v(" "),a("h2",{attrs:{id:"应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),a("p",[t._v("UDP 速度快，开销低，不用封包/拆包，允许丢一部分数据。适合用于监控统计、日志数据上报、流媒体通信等场景。目前 Node.js 的项目中使用 UDP 比较流行的是 "),a("a",{attrs:{href:"https://github.com/etsy/statsd",target:"_blank",rel:"noopener noreferrer"}},[t._v("StatsD"),a("OutboundLink")],1),t._v(" 监控服务。")]),t._v(" "),a("hr"),t._v(" "),a("p",[a("strong",[t._v("参考资料：")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"http://nodejs.cn/api/dgram.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("📖 Node Documentation dgram API"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000011366156",target:"_blank",rel:"noopener noreferrer"}},[t._v("📝 Node dgram 模块实现 UDP 通信"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=n.exports}}]);