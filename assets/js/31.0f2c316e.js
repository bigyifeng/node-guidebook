(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{317:function(e,t,v){"use strict";v.r(t);var _=v(0),r=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"events"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#events"}},[e._v("#")]),e._v(" Events")]),e._v(" "),v("h2",{attrs:{id:"同步和异步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步和异步"}},[e._v("#")]),e._v(" 同步和异步")]),e._v(" "),v("h2",{attrs:{id:"仅处理事件一次"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#仅处理事件一次"}},[e._v("#")]),e._v(" 仅处理事件一次")]),e._v(" "),v("h2",{attrs:{id:"错误事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#错误事件"}},[e._v("#")]),e._v(" 错误事件")]),e._v(" "),v("h2",{attrs:{id:"eventemitter"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eventemitter"}},[e._v("#")]),e._v(" EventEmitter")]),e._v(" "),v("h3",{attrs:{id:"监听事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#监听事件"}},[e._v("#")]),e._v(" 监听事件")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("newListener")]),e._v("：EventEmitter 实例在新的监听器被添加到其内部监听器数组之前，会触发自身的 "),v("code",[e._v("newListener")]),e._v(" 事件。")]),e._v(" "),v("li",[v("code",[e._v("removeListener")]),e._v("："),v("code",[e._v("listener")]),e._v(" 被移除后触发。")])]),e._v(" "),v("h3",{attrs:{id:"静态方法-属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态方法-属性"}},[e._v("#")]),e._v(" 静态方法/属性")]),e._v(" "),v("h3",{attrs:{id:"实例方法-属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实例方法-属性"}},[e._v("#")]),e._v(" 实例方法/属性")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("emitter.addListener(eventName, listener)")]),e._v("："),v("code",[e._v("emiiter.on")]),e._v(" 的别名")]),e._v(" "),v("li",[v("code",[e._v("emiiter.emit(eventName [, ...args])")]),e._v("：按照监听器注册的顺序，同步地调用每个注册到名为 eventName 的事件的监听器，并传入提供的参数。")]),e._v(" "),v("li",[v("code",[e._v("emiiter.eventNames()")]),e._v("：返回已注册监听器的事件名数组。数组中的值为字符串或 "),v("code",[e._v("Symbol")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("emitter.getMaxListeners()")]),e._v("：返回 EventEmitter 当前的监听器最大限制数的值，可使用 "),v("code",[e._v("emitter.setMaxListeners(n)")]),e._v(" 设置或默认为 "),v("code",[e._v("EventEmitter.defaultMaxListeners")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("emitter.listenerCount(eventName)")]),e._v("：返回正在监听的名为 "),v("code",[e._v("eventName")]),e._v(" 的事件的监听器的数量。")]),e._v(" "),v("li",[v("code",[e._v("emitter.listeners(eventName)")]),e._v("：返回名为 "),v("code",[e._v("eventName")]),e._v(" 的事件的监听器数组的副本。")]),e._v(" "),v("li",[v("code",[e._v("emitter.off(eventName, listener)")]),e._v("："),v("code",[e._v("emitter.removeListener()")]),e._v(" 的别名")]),e._v(" "),v("li",[v("code",[e._v("emitter.on(eventName, listener)")]),e._v("：添加 "),v("code",[e._v("listener")]),e._v(" 函数到名为 "),v("code",[e._v("eventName")]),e._v(" 事件的监听器数组的末尾。不会检查 "),v("code",[e._v("listener")]),e._v(" 是否已被添加。多次调用并传入相同的 "),v("code",[e._v("eventName")]),e._v(" 与 "),v("code",[e._v("listener")]),e._v(" 会导致 "),v("code",[e._v("listener")]),e._v(" 会被添加多次。")]),e._v(" "),v("li",[v("code",[e._v("emitter.once(eventName, listener)")]),e._v("：添加单次监听器 "),v("code",[e._v("listener")]),e._v(" 到名为 "),v("code",[e._v("eventName")]),e._v(" 的事件。当 "),v("code",[e._v("eventName")]),e._v(" 事件下次触发时，监听器会先被移除，然后再调用。")]),e._v(" "),v("li",[v("code",[e._v("emitter.prependListener(eventName, listener)")]),e._v("：添加 "),v("code",[e._v("listener")]),e._v(" 函数到名为 "),v("code",[e._v("eventName")]),e._v(" 的事件的监听器数组的开头。不会检查 "),v("code",[e._v("listener")]),e._v(" 是否已被添加。多次调用并传入相同的 "),v("code",[e._v("eventName")]),e._v(" 和 "),v("code",[e._v("listener")]),e._v(" 会导致 "),v("code",[e._v("listener")]),e._v(" 被添加多次。")]),e._v(" "),v("li",[v("code",[e._v("emitter.prependOnceListener(eventName, listener)")]),e._v("：添加单次监听器 "),v("code",[e._v("listener")]),e._v(" 到名为 "),v("code",[e._v("eventName")]),e._v(" 的事件的监听器数组的开头。 当 "),v("code",[e._v("eventName")]),e._v(" 事件下次触发时，监听器会先被移除，然后再调用。")]),e._v(" "),v("li",[v("code",[e._v("emitter.removeAllListeners([eventName])")]),e._v("：移除全部监听器或指定的 "),v("code",[e._v("eventName")]),e._v(" 事件的监听器。删除代码中其它位置添加的监听器是不好的做法，尤其是当 "),v("code",[e._v("EventEmitter")]),e._v(" 实例是由某些其它组件或模块（例如套接字或文件流）创建时。")]),e._v(" "),v("li",[v("code",[e._v("emitter.removeListener(eventName, listener)")]),e._v("：从名为 "),v("code",[e._v("eventName")]),e._v(" 的事件的监听器数组中移除指定的 "),v("code",[e._v("listener")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("emitter.setMaxListeners(n)")]),e._v("：默认情况下，如果为特定事件添加了超过 10 个监听器，则 "),v("code",[e._v("EventEmitter")]),e._v(" 会打印一个警告，这有助于发现内存泄露。但是，并不是所有的事件都要限制 10 个监听器。"),v("code",[e._v("emitter.setMaxListeners()")]),e._v(" 方法可以为指定的 "),v("code",[e._v("EventEmitter")]),e._v(" 实例修改限制。值设为 "),v("code",[e._v("Infinity")]),e._v("（或 "),v("code",[e._v("0")]),e._v("）表示不限制监听器的数量。")]),e._v(" "),v("li",[v("code",[e._v("emitter.rawListeners(eventName)")]),e._v("：返回 "),v("code",[e._v("eventName")]),e._v(" 事件的监听器的拷贝，包括封装的监听器（例如由 "),v("code",[e._v(".once()")]),e._v(" 创建的）。")]),e._v(" "),v("li",[v("code",[e._v("events.once(emitter.name)")]),e._v("：创建一个 Promise，当 EventEmitter 触发给定的事件时则会被解决，当 EventEmitter 触发 "),v("code",[e._v("'error'")]),e._v(" 时则会被拒绝。解决 Promise 时将会带上触发到给定事件的虽有参数的数组。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);