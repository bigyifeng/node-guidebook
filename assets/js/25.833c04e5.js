(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{303:function(v,_,e){"use strict";e.r(_);var a=e(0),t=Object(a.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"架构升级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#架构升级"}},[v._v("#")]),v._v(" 架构升级")]),v._v(" "),e("p",[v._v("LAMP（Linux+Apache+MySQL+PHP） => MEAN（MongoDB+Express+Angular+NodeJS）")]),v._v(" "),e("p",[v._v("单体式结构（Monolithic Architect）")]),v._v(" "),e("ul",[e("li",[v._v("表现层：处理 HTTP 请求，直接返回 HTML 渲染，或者返回 API 结果。对于一个复杂的应用系统，表现层通常是代码中比较重要的部分。")]),v._v(" "),e("li",[v._v("业务逻辑层：完成具体的业务逻辑，是应用的核心组成部分")]),v._v(" "),e("li",[v._v("数据访问层：访问基础数据，例如数据库、缓存和消息队列等")])]),v._v(" "),e("p",[v._v("Java 后端分层：")]),v._v(" "),e("ul",[e("li",[v._v("先定义模型层（Model），数据库操作一般采用 ORM 库来简化操作，模型会和数据库里的表进行关联映射")]),v._v(" "),e("li",[v._v("DAO（Data Access Object）就是我们常说的增删改查，主要对单个模型进行操作")]),v._v(" "),e("li",[v._v("Service 层就是业务逻辑层，通常组合多个 DAO 对象进行某项业务处理")]),v._v(" "),e("li",[v._v("Controller 里组装了多个 Service 对象，可实现具体的功能")])]),v._v(" "),e("p",[v._v("组装 API、RPC 服务、提供配置、静态 API 接口等。")]),v._v(" "),e("ol",[e("li",[v._v("分两部分开发、部署和扩展")]),v._v(" "),e("li",[v._v("简化后端开发")])]),v._v(" "),e("p",[v._v("需求：负载均衡、请求转发、反向代理、静态资源托管、防跨域等")]),v._v(" "),e("p",[v._v("方式一：请求 => Nginx => 前端")]),v._v(" "),e("p",[v._v("前端引入 NodeJS 解决因处理下线、重定向、兼容多版本等问题而导致的 Nginx 时常变更的问题。")]),v._v(" "),e("p",[v._v("方式二：请求 => Nginx => NodeJS（前端）")]),v._v(" "),e("ul",[e("li",[v._v("提供请求转发、反向代理等功能")]),v._v(" "),e("li",[v._v("提供 Web 服务，所有后端语言（Java、PHP 等）能做到的，Node.js 都能做到")]),v._v(" "),e("li",[v._v("圈定范围，便于维护，只要修改功能包含在当前 Node.js 项目范围内即可维护")]),v._v(" "),e("li",[v._v("充当 HTTP 客户端，访问后端接口，但一般不直接访问数据库")])]),v._v(" "),e("p",[v._v("Nginx 负载均衡、反向代理、缓存、限流限速\n需要繁杂的配置文件，不能动态控制与实时生效")]),v._v(" "),e("hr"),v._v(" "),e("h2",{attrs:{id:"贯穿开发全过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#贯穿开发全过程"}},[v._v("#")]),v._v(" 贯穿开发全过程")]),v._v(" "),e("p",[v._v("Node.js 的应用场景主要分为 4 个大类：跨平台开发、后端开发、前端开发和工具开发。")]),v._v(" "),e("h3",{attrs:{id:"静态-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态-api"}},[v._v("#")]),v._v(" 静态 API")]),v._v(" "),e("h3",{attrs:{id:"现代-web-开发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#现代-web-开发"}},[v._v("#")]),v._v(" 现代 Web 开发")]),v._v(" "),e("p",[v._v("预处理器\n跨平台\n构建工具")]),v._v(" "),e("h3",{attrs:{id:"后端开发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后端开发"}},[v._v("#")]),v._v(" 后端开发")]),v._v(" "),e("p",[v._v("Web 应用\nAPI 代理\n服务组装\nAPI 网关")]),v._v(" "),e("h4",{attrs:{id:"severless"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#severless"}},[v._v("#")]),v._v(" Severless")]),v._v(" "),e("p",[v._v("Severless 是一种基于互联网技术的架构理念，采用函数即服务（Function as a Service，FaaS）架构理念，让开发者只关注应用逻辑，而不必将全部功能都在服务端实现，通过组合多个函数的功能来实现应用程序逻辑。采用 Serverless 架构能够让开发者在构建应用的过程中无须关注服务器运维，有效节省开发成本。其优势总结如下：")]),v._v(" "),e("ul",[e("li",[v._v("节约使用成本")]),v._v(" "),e("li",[v._v("简化设备运维过程")]),v._v(" "),e("li",[v._v("提升可维护性")])]),v._v(" "),e("h3",{attrs:{id:"更多的应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更多的应用场景"}},[v._v("#")]),v._v(" 更多的应用场景")]),v._v(" "),e("ul",[e("li",[v._v("作为基础设施用于前端开发")]),v._v(" "),e("li",[v._v("作为命令行辅助工具")]),v._v(" "),e("li",[v._v("用于移动端（Cordova）和 PC 端（NW.js 和 Electron）")]),v._v(" "),e("li",[v._v("实现前端组件化，完成组件的打包构建，增加 HTTP 代理等功能")]),v._v(" "),e("li",[v._v("用于架构设计，实现前后端分离")]),v._v(" "),e("li",[v._v("性能优化，反爬虫与爬虫")]),v._v(" "),e("li",[v._v("实现全栈")])])])}),[],!1,null,null,null);_.default=t.exports}}]);