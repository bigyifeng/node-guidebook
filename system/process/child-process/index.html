<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="/node-guidebook/umi.css" />
    <script>
      window.routerBase = "/node-guidebook/";
    </script>
    <script>
      //! umi version: 3.2.19
    </script>
    <title>子进程</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/node-guidebook-favicon.svg&#x27;)" href="/node-guidebook//">Node Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a href="/node-guidebook//overview">概览</a><a href="/node-guidebook//engine">引擎</a><a aria-current="page" class="active" href="/node-guidebook//system">系统</a><a href="/node-guidebook//network">网络</a><a href="/node-guidebook//server-application">服务端应用</a><a href="/node-guidebook//util-application">工具应用</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/node-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/node-guidebook-favicon.svg&#x27;)" href="/node-guidebook//"></a><h1>Node Guidebook</h1><p>Node 完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/node-guidebook//overview">概览</a></li><li><a href="/node-guidebook//engine">引擎</a></li><li><a aria-current="page" class="active" href="/node-guidebook//system">系统</a></li><li><a href="/node-guidebook//network">网络</a></li><li><a href="/node-guidebook//server-application">服务端应用</a></li><li><a href="/node-guidebook//util-application">工具应用</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/node-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a aria-current="page" class="active" href="/node-guidebook//system/process">进程</a><ul><li><a href="/node-guidebook//system/process/process"><span>进程</span></a></li><li><a aria-current="page" class="active" href="/node-guidebook//system/process/child-process"><span>子进程</span></a></li><li><a href="/node-guidebook//system/process/cluster"><span>集群</span></a></li><li><a href="/node-guidebook//system/process/ipc"><span>进程间通信</span></a></li><li><a href="/node-guidebook//system/process/daemon"><span>守护进程</span></a></li><li><a href="/node-guidebook//system/process/multiple-process-architecture"><span>多进程架构模型</span></a></li></ul></li><li><a href="/node-guidebook//system/io">异步 I/O</a><ul><li><a href="/node-guidebook//system/io/io"><span>概述</span></a></li><li><a href="/node-guidebook//system/io/buffer"><span>Buffer 缓冲器</span></a></li><li><a href="/node-guidebook//system/io/stream"><span>Stream 流</span></a></li><li><a href="/node-guidebook//system/io/readable-stream"><span>ReadableStream 可读流</span></a></li><li><a href="/node-guidebook//system/io/writable-stream"><span>WritableStream 可写流</span></a></li><li><a href="/node-guidebook//system/io/duplex-stream"><span>DuplexStream 双工流</span></a></li><li><a href="/node-guidebook//system/io/transform-stream"><span>TransformStream 转换流</span></a></li><li><a href="/node-guidebook//system/io/string-decoder"><span>StringDecoder 字符串解码</span></a></li><li><a href="/node-guidebook//system/io/path"><span>Path 路径</span></a></li><li><a href="/node-guidebook//system/io/filesystem"><span>File 文件系统</span></a></li><li><a href="/node-guidebook//system/io/console"><span>Console 控制台</span></a></li></ul></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="创建子进程" data-depth="2" class=""><a href="/node-guidebook//system/process/child-process#创建子进程"><span>创建子进程</span></a></li><li title="spawn" data-depth="3" class=""><a href="/node-guidebook//system/process/child-process#spawn"><span>spawn</span></a></li><li title="exec" data-depth="3" class=""><a href="/node-guidebook//system/process/child-process#exec"><span>exec</span></a></li><li title="execFile" data-depth="3" class=""><a href="/node-guidebook//system/process/child-process#execfile"><span>execFile</span></a></li><li title="fork" data-depth="3" class=""><a href="/node-guidebook//system/process/child-process#fork"><span>fork</span></a></li><li title="异步 vs 同步" data-depth="3" class=""><a href="/node-guidebook//system/process/child-process#异步-vs-同步"><span>异步 vs 同步</span></a></li><li title="应用场景" data-depth="2" class=""><a href="/node-guidebook//system/process/child-process#应用场景"><span>应用场景</span></a></li><li title="孤儿进程和僵尸进程" data-depth="2" class=""><a href="/node-guidebook//system/process/child-process#孤儿进程和僵尸进程"><span>孤儿进程和僵尸进程</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="子进程"><a aria-hidden="true" href="#子进程"><span class="icon icon-link"></span></a>子进程</h1><p>子进程 (Child Process) 是进程中一个重要的概念。我们可以通过 Node.js 的 <code>child_process</code> 模块衍生出一个子进程，并且父子进程使用一个消息系统相互之间可以很容易地交流。</p><p><code>child_process</code> 模块使我们在一个运行良好的子进程内运行一些能够进入操作系统的命令。</p><p>父进程可以控制子进程的输入流，并且监听它的输出流。也可以控制传递给潜在的操作系统命令的参数，我们可以通过那个命令的输出做我们想做的事情。比如：可以将一个命令的输出作为另一个的输入，因为哪些命令的输入和输出都是使用流的形式呈现给我们。</p><h2 id="创建子进程"><a aria-hidden="true" href="#创建子进程"><span class="icon icon-link"></span></a>创建子进程</h2><p>Node.js 的 child_process 内置模块提供了几种创建子进程的四种方式：</p><ul><li><code>child_process.spawn()</code>：适用于返回大量数据，例如图像处理，二进制数据处理</li><li><code>child_process.exec()</code>：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn</li><li><code>child_process.execFile()</code>：类似 <code>child_process.exec()</code>，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为</li><li><code>child_process.fork()</code>：衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通常根据系统 CPU 核心数设置</li></ul><h3 id="spawn"><a aria-hidden="true" href="#spawn"><span class="icon icon-link"></span></a>spawn</h3><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="child_process.spwan(command [, args] [, options])
" data-status="copy"></button><div class="token-line"><span class="token plain">child_process.spwan(command [, args] [, options])</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>创建父子进程间通信的三种方式：</p><ul><li>让子进程的 stdio 和当前进程的 stdio 之间建立管道链接 <code>child.stdout.pipe(process.stdout)</code></li><li>父进程子进程之间共用 stdio</li><li>事件监听</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="const spawn = require(&#x27;child_process&#x27;).spawn;
// cwd 指定子进程的工作目录，默认当前目录
const child = spwan(&#x27;ls&#x27;, [&#x27;-l&#x27;], { cwd: &#x27;/usr&#x27; });

child.stdout.pipe(process.stdout);
console.log(process.pid, child.pid);
// 主进程ID 3243 子进程ID 3244
" data-status="copy"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> spawn </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#x27;child_process&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">spawn</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// cwd 指定子进程的工作目录，默认当前目录</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">const</span><span class="token plain"> child </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">spwan</span><span class="token punctuation">(</span><span class="token string">&#x27;ls&#x27;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token string">&#x27;-l&#x27;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"> cwd</span><span class="token punctuation">:</span><span class="token plain"> </span><span class="token string">&#x27;/usr&#x27;</span><span class="token plain"> </span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">child</span><span class="token punctuation">.</span><span class="token property-access">stdout</span><span class="token punctuation">.</span><span class="token method function property-access">pipe</span><span class="token punctuation">(</span><span class="token plain">process</span><span class="token punctuation">.</span><span class="token property-access">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token plain">process</span><span class="token punctuation">.</span><span class="token property-access">pid</span><span class="token punctuation">,</span><span class="token plain"> child</span><span class="token punctuation">.</span><span class="token property-access">pid</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 主进程ID 3243 子进程ID 3244</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>通过 spawn 创建的子进程，继承自 EventEmitter，所以可以在上面进行事件（<code>discount</code>、<code>error</code>、<code>close</code>、<code>message</code>）的监听。同时子进程具有三个输入输出流：stdin、stdout、stderr，通过这三个流，可以实时获取子进程的输入输出和错误信息。</p><blockquote><p>这个方法的最终实现基于 libuv，参考<a href="https://github.com/nodejs/node/blob/v10.14.2/src/process_wrap.cc#L256" target="_blank" rel="noopener noreferrer">源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="__dumi-default-code-block"><pre class="prism-code language-cpp"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="// 调用 libuv 的 api，初始化一个进程
int err = uv_spawn(env-&gt;event.loop(), $wrap-&gt;process_, $options);
" data-status="copy"></button><div class="token-line"><span class="token comment">// 调用 libuv 的 api，初始化一个进程</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">int</span><span class="token plain"> err </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">uv_spawn</span><span class="token punctuation">(</span><span class="token plain">env</span><span class="token operator">-&gt;</span><span class="token plain">event</span><span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token plain"> $wrap</span><span class="token operator">-&gt;</span><span class="token plain">process_</span><span class="token punctuation">,</span><span class="token plain"> $options</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div></blockquote><h3 id="exec"><a aria-hidden="true" href="#exec"><span class="icon icon-link"></span></a>exec</h3><p><code>exec</code> 最终调用的就是下面的 <code>execFile</code> 方法（<a href="https://segmentfault.com/a/1190000017804200#" target="_blank" rel="noopener noreferrer">源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。唯一区别是，<code>exec</code> 中调用的 <code>normalizeExecArgs</code> 方法会将 opts 的 shell 属性默认设置为 <code>true</code>。</p><p><code>exec</code> 会将 spawn 的输入输出流转换为字符串，默认使用 UTF-8 的编码，然后传递给回调函数，使用回调方式在 Node.js 中较为熟悉，比流更容易操作，所以我们能使用 <code>exec</code> 方法执行一些 Shell 命令，然后在回调中获取返回值。有点需要注意，这里的 buffer 是有最大缓存区的，如果超出会直接被 kill 掉，可用通过 <code>maxBuffer</code> 属性进行配置（默认：200 * 1024）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="const exec = require(&#x27;child_process&#x27;).exec;

execFile(`node`, (error, stdout, stderr) =&gt; {
  console.log({ error, stdout, stderr });
  // { error: null, stdout: &#x27;v8.5.0\n&#x27;, stderr: &#x27;&#x27; }
});
" data-status="copy"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> exec </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#x27;child_process&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">exec</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token function">execFile</span><span class="token punctuation">(</span><span class="token template-string template-punctuation string">`</span><span class="token template-string string">node</span><span class="token template-string template-punctuation string">`</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token parameter punctuation">,</span><span class="token parameter"> stdout</span><span class="token parameter punctuation">,</span><span class="token parameter"> stderr</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token plain"> error</span><span class="token punctuation">,</span><span class="token plain"> stdout</span><span class="token punctuation">,</span><span class="token plain"> stderr </span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// { error: null, stdout: &#x27;v8.5.0\n&#x27;, stderr: &#x27;&#x27; }</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h3 id="execfile"><a aria-hidden="true" href="#execfile"><span class="icon icon-link"></span></a>execFile</h3><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="const execFile = require(&#x27;child_process&#x27;).execFile;

execFile(`node`, [&#x27;-v&#x27;], (error, stdout, stderr) =&gt; {
  console.llog({ errpr, stdout, stderr });
  // { error: null, stdout: &#x27;v8.5.0\n&#x27;, stderr: &#x27;&#x27; }
});
" data-status="copy"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> execFile </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#x27;child_process&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">execFile</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token function">execFile</span><span class="token punctuation">(</span><span class="token template-string template-punctuation string">`</span><span class="token template-string string">node</span><span class="token template-string template-punctuation string">`</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token string">&#x27;-v&#x27;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token parameter punctuation">,</span><span class="token parameter"> stdout</span><span class="token parameter punctuation">,</span><span class="token parameter"> stderr</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">llog</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token plain"> errpr</span><span class="token punctuation">,</span><span class="token plain"> stdout</span><span class="token punctuation">,</span><span class="token plain"> stderr </span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// { error: null, stdout: &#x27;v8.5.0\n&#x27;, stderr: &#x27;&#x27; }</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h3 id="fork"><a aria-hidden="true" href="#fork"><span class="icon icon-link"></span></a>fork</h3><p><code>fork</code> 最后也是调用 <code>spwan</code> 来创建子进程，但是 <code>fork</code> 是 <code>spawn</code> 的一种特殊情况，用于衍生新的 Node.js 进程，会产生一个新的 V8 实例，所以执行 <code>fork</code> 方法时需要指定一个 JS 文件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="const fork = require(&#x27;child_process&#x27;).fork;
fork(&#x27;./worker.js&#x27;); // fork 一个新的子进程
" data-status="copy"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> fork </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#x27;child_process&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">fork</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">&#x27;./worker.js&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token comment">// fork 一个新的子进程</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>通过 <code>fork</code> 创建子进程之后，父子进程直接会创建一个 IPC（进程间）通道，方便父子进程直接通信，在 JS 层使用 <code>process.send(message)</code> 和 <code>process.on(&#x27;message&#x27;, msg =&gt; <!-- -->{}<!-- -->)</code> 进行通信。二在底层，实现进程间通信的方式有很多，Node.js 的进程间通信基于 libuv 实现，不同操作系统实现方式不一致，在 *unix 系统中采用 Unix Domain Socket 方式实现，Windows 中使用命名管道的方式实现。</p><p>常见进程间通信方式：</p><ul><li>消息队列</li><li>共享内存</li><li><code>pipe</code></li><li>信号量</li><li>套接字</li></ul><p>可以看到，这些方法都是对 <code>spawn</code> 方法的复用，然后 <code>spawn</code> 方法底层调用 libuv 进行进程的管理。</p><p><img src="/node-guidebook/static/create-child-process.fda8b9aa.png"/></p><h3 id="异步-vs-同步"><a aria-hidden="true" href="#异步-vs-同步"><span class="icon icon-link"></span></a>异步 vs 同步</h3><p>大部分时候，子进程的创建是异步的。也就是说，它不会阻塞当前的事件循环，这对于性能的提升很有帮助。</p><p>当然，有的时候，同步的方式会更方便（阻塞事件循环），比如通过子进程的方式来执行 shell 脚本时。</p><p>Node.js 同样提供同步的版本：</p><ul><li><code>spawnSync()</code></li><li><code>execSync()</code></li><li><code>execFileSync()</code></li></ul><h2 id="应用场景"><a aria-hidden="true" href="#应用场景"><span class="icon icon-link"></span></a>应用场景</h2><p>子进程的应用场景：</p><ul><li>计算密集型系统</li><li>前端构建工具利用多核 CPU 并行计算，提升构建效率</li><li>进程管理工具，如：PM2 中部分功能</li></ul><h2 id="孤儿进程和僵尸进程"><a aria-hidden="true" href="#孤儿进程和僵尸进程"><span class="icon icon-link"></span></a>孤儿进程和僵尸进程</h2><blockquote><p>经典面试题：父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?</p></blockquote><p>子进程死亡不会影响父进程，不过子进程死亡时（线程组的最后一个线程，通常是「领头」线程死亡时），会向它的父进程发送死亡信号。反之父进程死亡，一般情况下子进程也会随之死亡。但如果此时父进程对应的一个或多个子进程处于可运行态、僵死状态等等的话，子进程将被系统的 init 进程收养（对应的 ppid 为 1），从而成为<strong>孤儿进程</strong>。</p><p>另外，子进程死亡的时候（处于“终止状态”），父进程没有及时调用 <code>wait()</code> 或 <code>waitpid()</code> 来返回死亡进程的相关信息，此时子进程还有一个 PCB 残留在进程表中，被称作<strong>僵尸进程</strong>。</p><p>🌰 <strong>孤儿进程 示例代码</strong></p><p>&lt;&lt;&lt; @/example/child-process/orphan-process/master.js</p><p>&lt;&lt;&lt; @/example/child-process/orphan-process/worker.js</p><p>控制台进行调试，输出当前工作进程 pid 和父进程 ppid</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="$ node master
worker process created, pid: 32971 ppid: 32970
" data-status="copy"></button><div class="token-line"><span class="token plain">$ node master</span></div><div class="token-line"><span class="token plain">worker process created, pid: </span><span class="token number">32971</span><span class="token plain"> ppid: </span><span class="token number">32970</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>由于在 master.js 里退出了父进程，活动监视器所显示的也就只有工作进程。</p><p>再次验证，打开控制台调用接口，可以看到工作进程 32971 对应的 ppid 为 1（为 init 进程），此时已经成为了孤儿进程。</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="$ curl http://127.0.0.1:3000
I am worker, pid: 32971, ppid: 1
" data-status="copy"></button><div class="token-line"><span class="token plain">$ </span><span class="token function">curl</span><span class="token plain"> http://127.0.0.1:3000</span></div><div class="token-line"><span class="token plain">I am worker, pid: </span><span class="token number">32971</span><span class="token plain">, ppid: </span><span class="token number">1</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><hr/><p><strong>参考资料：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/36678971" target="_blank" rel="noopener noreferrer">📝 Node.js 子进程：你需要知道的一切<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a href="https://segmentfault.com/a/1190000017804200" target="_blank" rel="noopener noreferrer">📝 Node.js 的进程管理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a href="https://blog.csdn.net/weixin_34161029/article/details/87998135" target="_blank" rel="noopener noreferrer">📝 Node.js 子进程与应用场景<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/node-guidebook/edit/master/docs/system/process/child-process.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last Update: ">9/4/2020, 3:39:37 PM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/node-guidebook/umi.js"></script>
    <script src="/node-guidebook/docs__system__process__child-process.md.js"></script>
  </body>
</html>
