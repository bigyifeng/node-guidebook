(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{202:function(e,v,t){e.exports=t.p+"assets/img/node-architect.8b11ca98.jpg"},315:function(e,v,t){"use strict";t.r(v);var o=t(0),s=Object(o.a)({},(function(){var e=this,v=e.$createElement,o=e._self._c||v;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"node-架构"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#node-架构"}},[e._v("#")]),e._v(" Node 架构")]),e._v(" "),o("p",[o("img",{attrs:{src:t(202),alt:"Node.js 架构图"}})]),e._v(" "),o("p",[e._v("Node.js 的结构大体分为三个部分：")]),e._v(" "),o("ol",[o("li",[o("strong",[e._v("Node.js 标准库")]),e._v("：这部分由 JavaScript 编写。也就是平时我们经常 "),o("code",[e._v("require")]),e._v(" 的各个模块，如："),o("code",[e._v("http")]),e._v("、"),o("code",[e._v("fs")]),e._v("、"),o("code",[e._v("express")]),e._v("、"),o("code",[e._v("request")]),e._v(" 等，这部分在源码的 "),o("code",[e._v("lib")]),e._v(" 目录下可以看到")]),e._v(" "),o("li",[o("strong",[e._v("Node bingdings")]),e._v("：Node.js 程序的 "),o("code",[e._v("main")]),e._v(" 函数入口，还有提供给 "),o("code",[e._v("lib")]),e._v(" 模块的 C++ 类接口，这一层是 JavaScript 与底层 C/C++ 沟通的桥梁，由 C++编写，这部分在源码的 "),o("code",[e._v("src")]),e._v(" 目录下可以看到")]),e._v(" "),o("li",[e._v("最底层，支持 Node.js 运行的关键：\n"),o("ul",[o("li",[o("strong",[e._v("V8 引擎")]),e._v("：用来解析、执行 JavaScript 代码的运行环境")]),e._v(" "),o("li",[o("strong",[e._v("libuv")]),e._v("：提供最底层的 I/O 操作接口，包括文件异步 I/O 的线程池管理和网络的 I/O 操作，是整个异步 I/O 实现的核心。这部分由 C/C++编写，在源码的 "),o("code",[e._v("deps")]),e._v(" 目录下可以看到。")])])])]),e._v(" "),o("p",[o("strong",[e._v("小结")]),e._v("：我们其实对 Node.js 的单线程一直由很深的误会。事实上，单线程指的是开发者编写的代码只能运行在一个线程单中（习惯称之为主线程），Node.js 并没有给 JavaScript 执行时创建新线程的能力，所以称为单线程，也就是所谓的主线程。其实，Node.js 中许多异步方法在具体的实现时（Node.js 底层封装了 libuv，它提供了线程池、事件池、异步 I/O 等模块功能，其完成了异步方法的具体实现），内部均采用了多线程机制。")])])}),[],!1,null,null,null);v.default=s.exports}}]);