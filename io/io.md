# I/O

在操作系统中，程序运行的空间分为**内核空间**和**用户空间**。我们常提到的异步 I/O，其实质就是用户空间中的程序不用依赖内核空间中的 I/O 操作实际完成，即可进行后续任务。

以下伪代码模仿了一个从磁盘上获取文件和一个从网络中获取文件的操作。异步 I/O 的效果就是 getFileFromNet 的调用不依赖于 getFile 调用的结束。

```js
getFile('file_path');
getFileFromNet('url');
```

如果以上两个任务的时间分别为 `m` 和 `n`。采用同步方式的程序要完成这两个任务的时间总花销会是 `m + n`。但是如果是采用异步方式的程序，在两种 I/O 可以并行的状况下（比如网络 I/O 与文件 I/O），时间开销将会减小为 `max(m, n)`。

> 在 Node.js 中 I/O 主要指由 [libuv](http://libuv.org/) 支持的，与系统磁盘和网络之间的交互。

## 必要性

有的语言为了设计得使应用程序调用方便，将程序设计为同步 I/O 模型。这意味着程序中的后续任务都需要等待 I/O 的完成。在等待 I/O 完成的过程中，程序无法充分利用 CPU。为了充分利用 CPU，和使 I/O 可以并行，目前有两种方式可以达到目的：

- **多线程单进程**：多线程的设计之处就是为了**在共享的程序空间中，实现并行处理任务**，从而达到充分利用 CPU 的效果。多线程的缺点在于执行时上下文交换的开销较大，和状态同步（锁）的问题。同样它也使得程序的编写和调用复杂化。但是多线程在多核 CPU 上能够有效提升 CPU 的利用率，这个优势是毋庸置疑的。
- **单线程多进程**：单线程顺序执行任务的方式比较符合编程人员按顺序思考的思维方式。它依然是最主流的编程方式。但是串行执行的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞。为了避免多线程造成的使用不便问题，有的语言选择了单线程保持调用简单化，采用启动多进程的方式来达到充分利用 CPU 和提升总体的并行处理能力。 它的缺点在于业务逻辑复杂时（涉及多个 I/O 调用），因为业务逻辑不能分布到多个进程之间，事务处理时长要远远大于多线程模式。

目前的大型 Web 应用中，单机的情形是十分稀少的，一个事务往往需要跨越网络几次才能完成最终处理。如果网络速度不够理想，`m` 和 `n` 值都将会变大，这时同步 I/O 的语言模型将会露出其最脆弱的状态。

这种场景下的异步 I/O 将会体现其优势，`max(m, n)` 的时间开销可以有效地缓解 `m` 和 `n` 值增长带来的性能问题。而当并行任务更多的时候，`m + n + …` 与 `max(m, n, …)` 之间的孰优孰劣更是一目了然。从这个公式中，可以了解到异步 I/O 在分布式环境中是多么重要，而 Node.js 天然地支持这种异步 I/O，这是众多云计算厂商对其青睐的根本原因。

### 用户体验

浏览器中 JavaScript 在单线程上执行，而且它还是与 UI 渲染共用一个线程的。这意味着 JavaScript 在执行的时候 UI 渲染和响应是处于停滞状态的。

### 资源分配

操作系统会将 CPU 的时间片分配给其余进程，以公平而有效地利用资源，基于这一点，有的服务器为了提升响应能力，会通过启动多个工作进程来为更多的用户服务。但是对于这一组任务而言，它无法分发任务到多个进程上，所以依然无法高效利用资源，结束所有任务所需的时间将会较长。这种模式类似于加三倍服务器，达到占用更多资源来提升服务速度，它并没有真正改善问题。

添加硬件资源是一种提升服务质量的方式，但它不是唯一的方式。

单线程同步编程模型会因阻塞 I/O 导致硬件资源得不到更优的使用。多线程编程模型也因为编程中的死锁、状态同步等问题让开发人员头疼。

Node 在两者之间给出了方法：利用单线程，远离多线程死锁、状态同步等问题；利用异步 I/O，让单线程远离阻塞，以更好地利使用 CPU。

为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效地了利用 CPU 和 I/O。

## 操作系统支持

### 阻塞与非阻塞

阻塞模式的 I/O 会造成应用程序等待，直到 I/O 完成。同时操作系统也支持将 I/O 操作设置为非阻塞模式，这时应用程序的调用将可能在没有拿到真正数据时就立即返回了，为此应用程序需要多次调用才能确认 I/O 操作完全完成。

### 同步与异步

I/O 的同步与异步出现在应用程序中。如果做阻塞 I/O 调用，应用程序等待调用的完成的过程就是一种同步状况，相反，I/O 为非阻塞模式时，应用程序则是异步的。

## 轮询技术

当进行非阻塞 I/O 调用时，要读到完整的数据，应用程序需要进行多次轮询，才能确保读取数据完成，以进行下一步的操作。轮询技术的缺点在于应用程序要主动调用，会造成占用较多 CPU 时间片，性能较为低下。现存的轮询技术有以下这些：

- read
- select
- poll
- epoll
- pselect
- kqueue

---

**参考资料：**

- [阻塞对比非阻塞一览](https://nodejs.org/zh-cn/docs/guides/blocking-vs-non-blocking/)
- [事件循环机制概述](https://zhuanlan.zhihu.com/p/37427130/edit)
- [Timers、Immediates、nextTick](https://zhuanlan.zhihu.com/p/37563244)
- [Promise、nextTick、immediate](https://zhuanlan.zhihu.com/p/37714012)
- [处理 I/O](https://zhuanlan.zhihu.com/p/37756195)
- [最佳实践](https://zhuanlan.zhihu.com/p/37793218)
- [初探 Node.js 的异步 I/O 实现](https://www.infoq.cn/article/nodejs-asynchronous-io/)
